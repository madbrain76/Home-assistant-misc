# SPDX-License-Identifier: MPL-2.0
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

blueprint:
  name: Vacancy switch (auto-off/manual-on) light control with optional motion-based reactivation
  description: >
    Smart occupancy-based light automation. Light must be manually / externally turned on.

    This automation will then automatically turn off the light if there is no motion for the
    deactivation timeout duration. The goal is saving energy when a room is unoccupied.

    Optionally, it will reactivate the light, if motion is detected
    immediately after being turned off by this automation, during the reactivation timeout period.

    This is intended to be used with smart lights that are always available for control by Home
    Assistant on the network 24/7.

    This automation mimicks the behavior of California Title 24 compliant hard-wired vacancy
    "dumb" switches, but is compatible with smart light bulbs.

    Traditional vacancy switches, such as the Leviton IPP15/IPP0R series I was
    previously using, have a relay, which always cuts power to the load eventually, with the
    only possibility of turning it back on being a physical press of the switch.

    Unfortunately, the maximum deactivation timeout on these units is 30 minutes, configurable
    by physical setting inside the switch. The deactivation behavior cannot be disabled
    entirely. This makes these switches completely incompatible with smart bulbs.

    I ended up replacing all my Leviton IPP15/IPP0R switches with Z-wave switches as a result,
    Zooz ZEN76 and ZEN75. These switches are configured with the power relay always on, which
    allows the smart bulbs to remain on the network, and always controllable.

    The switches are used solely as scene controllers. This means that smart lights are then exclusively
    controllable by HA automations, such as this one, and other automations I use based on
    the scene controller presses with Z-Wave JS, or infrared remote presses. For IR control, I use an
    ARRX18G  universal remote programmed with Remote Master, in conjunction with an AtHom AR-01 Wifi
    IR receiver/blaster.
  domain: automation
  source_url: https://github.com/madbrain76/Home-assistant-misc/vacancy-switch.yaml

  input:
    light:
      name: Light
      description: Light entity to control
      selector:
        entity:
          domain: light

    motion_sensor:
      name: Motion Sensor
      description: Motion sensor entity to monitor
      selector:
        entity:
          domain: binary_sensor
          device_class: motion

    timeout:
      name: Timeout
      description: How long to wait for motion before turning off the light
      selector:
        duration:
      default:
        minutes: 5

    reactivation_timeout:
      name: Reactivation Timeout
      description: How long to wait for motion after turning off the light to reactivate it
      selector:
        duration:
      default:
        seconds: 30

trigger:
  - platform: homeassistant
    event: start
    id: ha_start

  - platform: event
    event_type: automation_reloaded
    id: automation_reload

  - platform: state
    entity_id: !input light
    to: "on"
    id: light_on

  - platform: state
    entity_id: !input motion_sensor
    to: "off"
    for: !input timeout
    id: motion_clear

mode: restart

variables:
  light_entity: !input light
  motion_entity: !input motion_sensor
  timeout: !input timeout
  reactivation_timeout: !input reactivation_timeout
  # Capture state at trigger time to avoid race conditions from state changes during execution
  motion_state_at_trigger: "{{ states[motion_entity] }}"
  light_state_at_trigger: "{{ states[light_entity] }}"

action:
  - service: system_log.write
    data:
      message: "VACANCY: trigger={{ trigger.id }}, light={{ states[light_entity] }}, motion={{ states[motion_entity] }}"
      level: debug

  # Case 1: HA start/reload or light turned on - wait for motion first
  - if:
      - condition: or
        conditions:
          - condition: and
            conditions:
              - condition: or
                conditions:
                  - condition: trigger
                    id: ha_start
                  - condition: trigger
                    id: automation_reload
              - condition: template
                value_template: "{{ light_state_at_trigger == 'on' }}"
              - condition: template
                value_template: "{{ motion_state_at_trigger == 'off' }}"
          - condition: and
            conditions:
              - condition: trigger
                id: light_on
              - condition: template
                value_template: "{{ motion_state_at_trigger == 'off' }}"
    then:
      - service: system_log.write
        data:
          message: "CASE1: Waiting for motion with timeout {{ timeout }}"
          level: debug
      - wait_for_trigger:
          - platform: state
            entity_id: !input motion_sensor
            to: "on"
        timeout: !input timeout
        continue_on_timeout: true
      - service: system_log.write
        data:
          message: "CASE1: wait complete, motion_detected={{ wait.trigger is not none }}"
          level: debug

  # Case 2: Turn off light (runs if motion_clear OR if Case 1 timed out)
  - if:
      - condition: or
        conditions:
          - condition: trigger
            id: motion_clear
          - condition: template
            value_template: "{{ trigger.id != 'light_on' or (trigger.id == 'light_on' and wait is defined and wait.trigger is none) }}"
      - condition: template
        value_template: "{{ motion_state_at_trigger == 'off' }}"
    then:
      - service: system_log.write
        data:
          message: "CASE2: Turning off light"
          level: debug
      - if:
          - condition: template
            value_template: "{{ light_state_at_trigger == 'on' }}"
        then:
          - service: light.turn_off
            target:
              entity_id: !input light

      # Case 3: Wait for motion during reactivation timeout to reactivate light
      - service: system_log.write
        data:
          message: "CASE3: Waiting for motion during reactivation timeout {{ reactivation_timeout }}"
          level: debug
      - wait_for_trigger:
          - platform: state
            entity_id: !input motion_sensor
            to: "on"
        timeout: !input reactivation_timeout
        continue_on_timeout: true
      - service: system_log.write
        data:
          message: "CASE3: reactivation wait complete, motion_detected={{ wait.trigger is not none }}"
          level: debug
      
      # Case 4: Reactivate light if motion detected during reactivation timeout
      - if:
          - condition: template
            value_template: "{{ wait.trigger is not none }}"
        then:
          - service: system_log.write
            data:
              message: "CASE4: Motion detected, reactivating light"
              level: debug
          - service: light.turn_on
            target:
              entity_id: !input light
